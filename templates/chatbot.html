<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>MicrobiomeBot - XAI Chatbot</title>
      
        
        <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
        
        <script>
            function formatCellValue(value) {
              if (value === undefined || value === null) return { text: "", className: "" };
            
              const s = String(value);
              const isSequence = /^[ACGTNacgtn]+$/i.test(s); 
              const limit = isSequence ? 12 : 32;           
            
              if (s.length > limit) {
                return {
                  text: s.slice(0, limit) + "‚Ä¶",    
                  title: s,                         
                  className: isSequence ? "truncate-cell seq" : "truncate-cell"
                };
              }
              return {
                text: s,
                title: s,
                className: isSequence ? "truncate-cell seq" : "truncate-cell"
              };
            }
        </script>
            
        
        <script>
        async function previewSelectedCSVs() {
          const boxes = Array.from(document.querySelectorAll('.csv-checkbox:checked'));
          if (boxes.length === 0) {
            addMessage('ü§ñ', '‚ö†Ô∏è No CSVs selected. Check one or more CSVs, then click **Preview Selected**.');
            return;
          }
          const filenames = boxes.map(b => b.value);
          try {
            const res = await fetch('/preview_csvs', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ filenames })
            });
            const out = await res.json();
            if (!out.success) { addMessage('ü§ñ', `‚ùå Preview failed: ${out.error || 'unknown error'}`); return; }
            out.previews.forEach(prev => {
              if (prev.error) { addMessage('ü§ñ', `‚ö†Ô∏è ${prev.filename}: ${prev.error}`); return; }
              const container = document.createElement('div');
              container.className = 'network-container';
              const isOTU = prev.filename === "otu_table.csv";
              container.innerHTML = `<h3>Preview: ${prev.filename} <small style="color:#6c757d">(${prev.csv_type || 'generic'})</small></h3>`;
              const table = document.createElement('table');
              const thead = document.createElement('thead');
              const trh = document.createElement('tr');
              (prev.columns || []).forEach(col => {
                const th = document.createElement('th');
                th.textContent = col;
                th.style.border = '1px solid #e9ecef';
                th.style.padding = '6px';
                th.style.background = '#f1f3f5';
                th.style.textAlign = 'left';
                if (isOTU) {
                  th.style.maxWidth = "60px";   
                  th.style.overflow = "hidden";
                  th.style.textOverflow = "ellipsis";
                  th.style.whiteSpace = "nowrap";
                  th.title = col; // shows full name on hover
                }
                trh.appendChild(th);
              });
              thead.appendChild(trh);
              table.appendChild(thead);
              const tbody = document.createElement('tbody');
              (prev.rows || []).forEach(row => {
                const tr = document.createElement('tr');
                (prev.columns || []).forEach(col => {
                  const td = document.createElement('td');
                  const v = row[col];
                  const { text, title, className } = formatCellValue(v);
                  td.textContent = text;            // truncated in-cell value
                  if (title) {
                    td.title = title;
                    td.dataset.fullvalue = title;      // full value on hover tooltip
                  }
                  td.className = (td.className ? td.className + " " : "") + (className || "truncate-cell");
                  td.style.border = '1px solid #e9ecef';
                  td.style.padding = '6px';
                  if (isOTU) {
                    td.style.maxWidth = "60px";   
                    td.style.overflow = "hidden";
                    td.style.textOverflow = "ellipsis";
                    td.style.whiteSpace = "nowrap";
                  }
                  tr.appendChild(td);
                });
                tbody.appendChild(tr);
              });
              table.appendChild(tbody);
              container.appendChild(table);
              document.getElementById('chatContainer').appendChild(container);
            });
            document.getElementById('chatContainer').scrollTop = document.getElementById('chatContainer').scrollHeight;
          } catch (e) {
            addMessage('ü§ñ', `‚ùå Preview error: ${e.message}`);
          }
        }

                
                document.addEventListener('DOMContentLoaded', () => {
            
            const header = document.getElementById('edgeExplainToggle');
            const content = document.getElementById('edgeExplainContent');

            if (header && content) {
                function toggle(open){
                    const isOpen = (open !== undefined) ? open : content.hasAttribute('hidden');
                    if (isOpen){
                        content.removeAttribute('hidden');
                        header.setAttribute('aria-expanded', 'true');
                    } else {
                        content.setAttribute('hidden', '');
                        header.setAttribute('aria-expanded', 'false');
                    }
                }

                header.addEventListener('click', () => toggle());
                header.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggle(); }
                    if (e.key === 'ArrowRight') toggle(true);
                    if (e.key === 'ArrowLeft')  toggle(false);
                });

                
                toggle(false);
               
                ['exSpecies1','exSpecies2','exLabel'].forEach(id=>{
                    const el = document.getElementById(id);
                    if (el) el.addEventListener('focus', openExplainPanel);
                });
            }
            
            
            updateFilesList();
        });
      
      
        // Show chosen CSV filenames
        function updateFileDisplay() {
          const input = document.getElementById('dataFile');
          const out = document.getElementById('csv-file-display');
          const files = Array.from(input.files || []);
          out.innerHTML = files.length ? files.map(f => `‚Ä¢ ${f.name}`).join('<br>') : '';
        }

        async function compareSelectedCSVs() {
  // Collect exactly two checked file names
  const checked = Array.from(document.querySelectorAll('.csv-checkbox:checked')).map(x => x.value);
  if (checked.length === 0) {
    addMessage('ü§ñ', '‚ö†Ô∏è No CSVs selected. Please check two CSVs in the left panel, then say **compare selected csvs**.');
    updateStatus('Ready');
    return;
  }
  if (checked.length === 1) {
    addMessage('ü§ñ', `‚ö†Ô∏è You selected one CSV (<code>${checked[0]}</code>). Please select **exactly two** CSVs to compare.`);
    updateStatus('Ready');
    return;
  }
  if (checked.length > 2) {
    addMessage('ü§ñ', `‚ö†Ô∏è You selected ${checked.length} CSVs. Please select **exactly two**.`);
    updateStatus('Ready');
    return;
  }

  const chat = document.getElementById('chatContainer');
  const card = document.createElement('div');
  card.className = 'network-container';
  card.innerHTML = `<h3>Compare CSVs</h3><p class="muted">Working‚Ä¶</p>`;
  chat.appendChild(card);
  chat.scrollTop = chat.scrollHeight;

  
  const list = (arr, empty='‚Äî') =>
    (arr && arr.length) ? `<code>${arr.join('</code>, <code>')}</code>` : `<span class="muted">${empty}</span>`;
  const cap  = (x) => (x ?? '‚Äî');
  const safeId = (prefix) => `${prefix}_${Date.now()}_${Math.random().toString(36).slice(2,8)}`;

  try {
    const res = await fetch('/compare_csvs', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ filenames: checked })
    });
    const out = await res.json();

    if (!out || !out.success) {
      card.innerHTML = `<h3>Compare CSVs</h3><p style="color:#dc3545">‚ùå ${out?.error || 'Comparison failed'}</p>`;
      return;
    }

    
    const A = out.summary?.file_a || {};
    const B = out.summary?.file_b || {};
    const schema = out.schema || {};
    const taxon  = out.taxon  || {};

    card.innerHTML = `
      <h3>Compare CSVs</h3>

      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:12px;">
        <div>
          <p><strong>${cap(A.filename)}</strong></p>
          <p class="muted">Rows: ${cap(A.rows)} ¬∑ Cols: ${cap(A.cols)}</p>
        </div>
        <div>
          <p><strong>${cap(B.filename)}</strong></p>
          <p class="muted">Rows: ${cap(B.rows)} ¬∑ Cols: ${cap(B.cols)}</p>
        </div>
      </div>

      <div style="margin-bottom:10px">
        <p><strong>Shared columns</strong> (${(schema.shared_columns || []).length})</p>
        <p>${list(schema.shared_columns)}</p>
      </div>

      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:10px;">
        <div>
          <p><strong>Only in ${cap(A.short || 'A')}</strong> (${(schema.only_in_a || []).length})</p>
          <p>${list(schema.only_in_a)}</p>
        </div>
        <div>
          <p><strong>Only in ${cap(B.short || 'B')}</strong> (${(schema.only_in_b || []).length})</p>
          <p>${list(schema.only_in_b)}</p>
        </div>
      </div>

      <div>
        <p><strong>Taxon/Feature overlap</strong> ${taxon.column_used ? `(by <code>${taxon.column_used}</code>)` : '<span class="muted">(no matching ID columns)</span>'}</p>
        <p>Overlap: <strong>${cap(taxon.overlap_count)}</strong> ¬∑ Only in ${cap(A.short || 'A')}: <strong>${cap(taxon.only_in_a_count)}</strong> ¬∑ Only in ${cap(B.short || 'B')}: <strong>${cap(taxon.only_in_b_count)}</strong></p>
        ${(taxon.sample && (taxon.sample.overlap || []).length) ? `
          <details style="margin-top:6px;">
            <summary>Show examples</summary>
            <p class="muted">Overlap: ${list(taxon.sample.overlap)}</p>
            <p class="muted">Only in ${cap(A.short || 'A')}: ${list(taxon.sample.only_in_a)}</p>
            <p class="muted">Only in ${cap(B.short || 'B')}: ${list(taxon.sample.only_in_b)}</p>
          </details>` : ''
        }
      </div>

      ${out.data_quality ? `
      <div style="margin-top:16px;">
        <p><strong>üìä Data Quality</strong></p>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;">
          <div>
            <p class="muted">Missing values: ${out.data_quality.missing_values.file_a}</p>
            <p class="muted">Duplicate rows: ${out.data_quality.duplicate_rows.file_a}</p>
            <p class="muted">Completeness: ${(out.data_quality.completeness_ratio.file_a * 100).toFixed(1)}%</p>
          </div>
          <div>
            <p class="muted">Missing values: ${out.data_quality.missing_values.file_b}</p>
            <p class="muted">Duplicate rows: ${out.data_quality.duplicate_rows.file_b}</p>
            <p class="muted">Completeness: ${(out.data_quality.completeness_ratio.file_b * 100).toFixed(1)}%</p>
          </div>
        </div>
      </div>` : ''}

      ${out.statistics ? `
      <div style="margin-top:16px;">
        <p><strong>üìà Statistical Analysis</strong></p>
        <p class="muted">Numeric columns analyzed: ${out.statistics.numeric_columns_count}</p>
        ${out.statistics.correlations && Object.keys(out.statistics.correlations).length > 0 ? `
          <details>
            <summary>Column Correlations</summary>
            ${Object.entries(out.statistics.correlations).slice(0,5).map(([col, corr]) =>
              `<p class="muted">${col}: ${(+corr).toFixed(3)}</p>`
            ).join('')}
          </details>` : ''}
      </div>` : ''}

      ${out.sample_analysis ? `
      <div style="margin-top:16px;">
        <p><strong>üîó Similarity Analysis</strong></p>
        <p class="muted">Jaccard similarity: ${(out.sample_analysis.jaccard_similarity * 100).toFixed(1)}% (${out.sample_analysis.similarity_category})</p>
        <p class="muted">Column overlap: ${out.sample_analysis.column_overlap_percentage.toFixed(1)}%</p>
      </div>` : ''}

      ${out.diversity_metrics ? `
      <div style="margin-top:16px;">
        <p><strong>üß¨ Diversity Metrics</strong></p>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;">
          <div>
            <p class="muted">Shannon diversity: ${out.diversity_metrics.shannon_diversity.file_a.toFixed(2)}</p>
            <p class="muted">Richness: ${out.diversity_metrics.richness.file_a}</p>
          </div>
          <div>
            <p class="muted">Shannon diversity: ${out.diversity_metrics.shannon_diversity.file_b.toFixed(2)}</p>
            <p class="muted">Richness: ${out.diversity_metrics.richness.file_b}</p>
          </div>
        </div>
      </div>` : ''}

      ${out.recommendations ? `
      <div style="margin-top:16px;">
        <p><strong>üí° Recommendations</strong></p>
        <p class="muted">Compatibility: ${out.recommendations.data_compatibility}</p>
        <p class="muted">Merge feasibility: ${out.recommendations.merge_feasibility}</p>
        <p class="muted">Quality score: ${(out.recommendations.quality_score * 100).toFixed(1)}%</p>
        ${out.recommendations.suggested_actions && out.recommendations.suggested_actions.length > 0 ? `
          <details>
            <summary>Suggested Actions</summary>
            ${out.recommendations.suggested_actions.map(action =>
              `<p class="muted">‚Ä¢ ${action}</p>`
            ).join('')}
          </details>` : ''}
      </div>` : ''}
    `;

    
    if (!taxon.column_used && out.numeric_fallback) {
      const nf = out.numeric_fallback;
      const s = nf.summary || {};
      const nfDiv = document.createElement('div');
      nfDiv.style.marginTop = '16px';
      nfDiv.innerHTML = `
        <p><strong>üßÆ Numeric fallback (no row IDs matched)</strong></p>
        <p class="muted">Shared numeric sample columns: ${nf.shared_samples?.length || 0}</p>
        <p class="muted">Mean 1‚àíBray‚ÄìCurtis: ${(s.mean_bray_curtis_similarity || 0).toFixed(3)} ¬∑ Mean Spearman: ${Number.isFinite(s.mean_spearman) ? s.mean_spearman.toFixed(3) : '‚Äî'}</p>
        ${nf.per_sample && nf.per_sample.length ? `
          <details style="margin-top:6px;">
            <summary>Per-sample summary (first 12)</summary>
            <div style="overflow:auto;margin-top:6px;">
              <table>
                <thead><tr><th>Sample</th><th>1‚àíBray‚ÄìCurtis</th><th>Spearman</th><th>Pearson</th></tr></thead>
                <tbody>
                  ${nf.per_sample.slice(0,12).map(d =>
                    `<tr>
                       <td>${escapeHtml(d.sample)}</td>
                       <td>${(+d.bray_curtis_similarity).toFixed(3)}</td>
                       <td>${Number.isFinite(d.spearman) ? (+d.spearman).toFixed(3) : '‚Äî'}</td>
                       <td>${Number.isFinite(d.pearson) ? (+d.pearson).toFixed(3) : '‚Äî'}</td>
                     </tr>`
                  ).join('')}
                </tbody>
              </table>
            </div>
          </details>` : ''}
      `;
      card.appendChild(nfDiv);
    }

    
    const plots = out.plots || {};
    const plotOrder = [
      ['overlap_bar', 'ID Overlap'],
      ['corr_bar', 'Column Correlations'],
      ['degree_hist', 'Node Degree (File A)'],
      ['per_sample_bray', 'Per-sample 1 ‚àí Bray‚ÄìCurtis (fallback)'],
      ['per_sample_spearman', 'Per-sample Spearman (fallback)'],
    ];

    const plotsContainer = document.createElement('div');
    let hasAnyPlot = false;
    plotsContainer.style.marginTop = '16px';
    plotsContainer.innerHTML = `<p><strong>üìâ Visualizations</strong></p>`;

    plotOrder.forEach(([key, title]) => {
      const spec = plots[key];
      if (!spec || !spec.data || !spec.layout) return;
      hasAnyPlot = true;
      const id = safeId(`plot_${key}`);
      const section = document.createElement('div');
      section.style.marginTop = '10px';
      section.innerHTML = `<p class="muted">${title}</p><div id="${id}" style="height:360px"></div>`;
      plotsContainer.appendChild(section);

      
      queueMicrotask(() => {
        try {
          Plotly.newPlot(id, spec.data, spec.layout, { responsive: true });
        } catch (e) {
          console.error('Plot error:', key, e);
        }
      });
    });

    if (hasAnyPlot) card.appendChild(plotsContainer);

    chat.scrollTop = chat.scrollHeight;
  } catch (e) {
    card.innerHTML = `<h3>Compare CSVs</h3><p style="color:#dc3545">‚ùå ${e.message}</p>`;
  } finally {
    updateStatus('Ready');
  }
}


      
        
        </script>
        
      
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #ffffff;           
            height: 100vh;
            display: block;                
        }

        .container {
            width: 100vw;                  
            height: 100vh;                 
            max-width: 100vw;
            background: white;
            border-radius: 0;              
            box-shadow: none;              
            display: flex;
            overflow: hidden;
        }

        .sidebar {
            width: 300px;
            background: #f8f9fa;
            border-right: 1px solid #e9ecef;
            display: flex;
            flex-direction: column;
        }

        .sidebar-header {
            padding: 20px;
            background: #343a40;
            color: white;
            text-align: center;
        }

        .sidebar-header h2 {
            margin-bottom: 5px;
            font-size: 1.5em;
        }

        .sidebar-header p {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .sidebar-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .feature-section {
            margin-bottom: 25px;
        }

        .feature-section h3 {
            color: #343a40;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .feature-list {
            list-style: none;
        }

        .feature-list li {
            padding: 8px 0;
            color: #6c757d;
            font-size: 0.9em;
            border-bottom: 1px solid #e9ecef;
        }

        .feature-list li:last-child { border-bottom: none; }

        .muted { color:#6c757d; } 

        .upload-section {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .upload-section h3 { color: #1976d2; margin-bottom: 10px; }

        .file-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        .btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            width: 100%;
            font-size: 0.9em;
        }
        .btn:hover { background: #0056b3; }

        .main-content { flex: 1; display: flex; flex-direction: column; }

        .chat-header {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-header h1 { color: #343a40; font-size: 1.8em; }

        .status-indicator {
            padding: 5px 15px;
            background: #28a745;
            color: white;
            border-radius: 20px;
            font-size: 0.8em;
        }

        .chat-container {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #f8f9fa;
            scroll-behavior: smooth;
            padding-bottom: 12px;
        }

        .message {
            margin-bottom: 20px;
            display: flex;
            align-items: flex-start;
        }

        .message.user { justify-content: flex-end; }

        .message-content {
            max-width: 70%;
            padding: 15px 20px;
            border-radius: 20px;
            position: relative;
            box-sizing: border-box;
        }

        
        .long-message { max-height: 40vh; overflow-y: auto; }

        
        .message.user .message-content {
            white-space: pre-wrap;
            overflow-wrap: anywhere;
            word-break: break-word;
        }

        
        .message.bot .message-content { white-space: normal; }

        .message.user .message-content {
            background: #007bff;
            color: white;
            border-bottom-right-radius: 5px;
        }
        .message.bot .message-content {
            background: white;
            color: #343a40;
            border: 1px solid #e9ecef;
            border-bottom-left-radius: 5px;
        }

        .message-avatar {
            width: 40px; height: 40px;
            border-radius: 50%;
            margin: 0 10px;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; color: white;
            flex-shrink: 0;
        }
        .message.user .message-avatar { background: #007bff; }
        .message.bot  .message-avatar { background: #28a745; }

        .input-container {
            padding: 20px;
            background: white;
            border-top: 1px solid #e9ecef;
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .message-input {
            flex: 1;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 25px;
            outline: none;
            font-size: 1em;
            resize: none;
            min-height: 50px;
            max-height: 150px;
            font-family: inherit;
            line-height: 1.4;
            overflow-y: auto;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            word-break: break-all;
            overflow-wrap: break-word;
        }
        .message-input:focus { border-color: #007bff; }

        .send-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
        }
        .send-btn:hover    { background: #0056b3; }
        .send-btn:disabled { background: #6c757d; cursor: not-allowed; }

        .typing-indicator {
            display: none;
            padding: 10px 20px;
            background: #e9ecef;
            border-radius: 20px;
            margin: 10px 0;
            font-style: italic;
            color: #6c757d;
        }

        .network-container {
            margin: 20px 0;
            background: white;
            border-radius: 10px;
            padding: 20px;
            border: 1px solid #e9ecef;
        }

        .example-queries {
            background: #fff3cd;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .example-queries h4 { color: #856404; margin-bottom: 10px; }

        .example-query {
            background: white;
            padding: 8px 12px; margin: 5px 0;
            border-radius: 15px; cursor: pointer;
            font-size: 0.9em; border: 1px solid #ffeaa7;
        }
        .example-query:hover { background: #ffeaa7; }

        #uploaded-files-list { margin-top: 20px; }
        #files-display { padding: 10px; border: 1px solid #ddd; border-radius: 5px; }

        
        .otu-sequence { white-space: nowrap; overflow-x: auto; display: block; max-width: 100%; }

        
        .seq-wrap{
            white-space: normal;
            overflow-wrap: anywhere;
            word-break: break-word;
            font-family: ui-monospace, Menlo, Consolas, "Liberation Mono", monospace;
            line-height: 1.3;
            display: inline;
        }
        
        .seq-block{
            font-family: ui-monospace, Menlo, Consolas, "Liberation Mono", monospace;
            white-space: pre-wrap;
            word-break: break-word;
            line-height: 1.3;
            display: block;            
        }


        
        .user-long-token { display: inline-block; max-width: 100%; white-space: nowrap; overflow-x: auto; vertical-align: bottom; }

        table {
            table-layout: fixed;   
            width: 100%;           
            border-collapse: collapse;
        }

        
        .truncate-cell {
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
          max-width: 420px;  
        }

        .truncate-cell.seq { 
          font-family: ui-monospace, Menlo, Consolas, "Liberation Mono", monospace;
          letter-spacing: .02em;
          cursor: help;       
        }

        
        .accordion-header{
            display:flex;
            align-items:center;
            justify-content:space-between;
            cursor:pointer;
            user-select:none;
            font-weight:600;
            padding:6px 2px;
        }

        .accordion-header .chevron{
            transition: transform .18s ease;
            font-size: 1.1em;
            line-height: 1;
        }

        .accordion-header[aria-expanded="true"] .chevron{
            transform: rotate(90deg);
        }

        .accordion-content{
            margin-top:8px;
        }


        @media (max-width: 768px) {
            .container { flex-direction: column; height: 100vh; width: 100%; border-radius: 0; }
            .sidebar   { width: 100%; height: auto; max-height: 200px; }
            .message-content { max-width: 85%; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="sidebar-header">
                <h2> MicrobiomeBot</h2>
                <p>Explainable AI for Microbiome Analysis</p>
            </div>
            <div class="sidebar-content">
                <div class="upload-section">
                    <h3>Upload Data</h3>
                    <input type="file" class="file-input" id="dataFile" accept=".csv,.tsv,.txt,.pdf" multiple onchange="updateFileDisplay()">
                    <div id="csv-file-display" style="margin-top: 10px; font-size: 12px; color: #666;"></div>
                    <button class="btn" onclick="uploadData()">Upload & Analyze</button>
                    
                    <div class="upload-type" style="margin-top: 15px;">
                        <h3>Upload Research Papers</h3>
                        <input type="file" class="file-input" id="pdf-upload" accept=".pdf" multiple onchange="updatePdfDisplay()">
                        <div id="pdf-file-display" style="margin-top: 10px; font-size: 12px; color: #666;"></div>
                        <button class="btn" onclick="uploadFiles('pdf')">Upload & Process</button>
                    </div>
                    
                    <div id="uploaded-files-list">
                        <h4>Uploaded Files:</h4>
                        <div id="files-display"></div>
                    </div>
                    
                </div>

                <div class="feature-section">
                    <h3> What I Can Explain</h3>
                    <ul class="feature-list">
                        <li>Interaction types (Competition, Mutualism, etc.)</li>
                        <li>Logical reasoning behind inferences</li>
                        <li>Network topology and patterns</li>
                        <li>Statistical significance</li>
                        <li>Step-by-step analysis process</li>
                    </ul>
                </div>

                <div class="feature-section">
                    <h3> XAI Features</h3>
                    <ul class="feature-list">
                        <li>Abductive logic explanations</li>
                        <li>Compression value interpretations</li>
                        <li>Interactive network visualization</li>
                        <li>Natural language queries</li>
                        <li>Transparent reasoning process</li>
                    </ul>
                </div>

                <div class="example-queries">
                    <h4> Try These Queries</h4>
                    <div class="example-query" onclick="sendExampleQuery('What are the interaction types?')">What are the interaction types?</div>
                    <div class="example-query" onclick="sendExampleQuery('How does the analysis work?')">How does the analysis work?</div>
                    <div class="example-query" onclick="sendExampleQuery('Show me the network')">Show me the network</div>
                    <div class="example-query" onclick="sendExampleQuery('Depth plot')">Depth plot</div>
                    <div class="example-query" onclick="sendExampleQuery('help')">Help</div>
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="chat-header">
                <h1>Microbiome Interaction Analysis</h1>
                <div class="status-indicator" id="status">Ready</div>
            </div>

            <div class="chat-container" id="chatContainer">
                <div class="message bot">
                    <div class="message-avatar">ü§ñ</div>
                    <div class="message-content">
                        <strong>Welcome to MicrobiomeBot!</strong><br><br>
                        I'm an explainable AI assistant specialized in microbiome interaction analysis using the InfIntE framework. I can help you understand:
                        <br><br>
                        ‚Ä¢ How ecological interactions are inferred from abundance data<br>
                        ‚Ä¢ The logical reasoning behind each interaction<br>
                        ‚Ä¢ Network patterns and their biological significance<br>
                        ‚Ä¢ Statistical support for each inference<br>
                        <br>
                        Try asking me about interaction types, uploading your data, or how the analysis works!
                    </div>
                </div>
            </div>

            <div class="typing-indicator" id="typingIndicator">
                MicrobiomeBot is thinking...
            </div>

            <!-- Explained Interaction UI -->
            <div id="edgeExplainUI" class="network-container accordion" style="margin-top:10px">
                <div id="edgeExplainToggle" class="accordion-header" role="button" tabindex="0" aria-expanded="false">
                  <span>Explain an interaction</span>
                  <span class="chevron" aria-hidden="true">‚ñ∏</span>
                </div>
              
                <div id="edgeExplainContent" class="accordion-content" hidden>
                  <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;margin:10px 0;">
                    <input id="exSpecies1" class="file-input" placeholder="Enter the full otu Label  (e.g., CGGGACTT....)" />
                    <input id="exSpecies2" class="file-input" placeholder="Enter the full Otu Label (e.g., CGGGACTTA.....)" />
                  </div>
                  <div style="display:flex;gap:8px;">
                    <button class="btn" onclick="explainEdge()">Explain</button>
                    <button class="btn" style="background:#6c757d" onclick="runNullTest()">Null test (quick)</button>
                  </div>
                  <p class="muted" style="margin-top:8px">Tip: you can also click an edge in the network (if available) to auto-fill & explain.</p>
                </div>
              </div>              
  
            <div class="input-container">
                <textarea type="text" class="message-input" id="messageInput" 
                       placeholder="Ask me about microbiome interactions..." 
                       onkeypress="handleKeyPress(event)"
                       oninput="autoResize(this)"></textarea>
                <button class="send-btn" id="sendBtn" onclick="sendMessage()">Send</button>
            </div>
        </div>
    </div>

    <script>
        let chatHistory = [];
        let isAnalyzing = false;

        function updatePdfDisplay() {
            const input = document.getElementById('pdf-upload');
            const out   = document.getElementById('pdf-file-display');
            const files = Array.from(input.files || []);
            out.innerHTML = files.length ? files.map(f => `‚Ä¢ ${f.name}`).join('<br>') : '';
        }

        function updateStatus(message, color = '#28a745') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.style.background = color;
        }

        function updateProgress(message, percentage = null) {
            const status = document.getElementById('status');
            if (percentage !== null) {
                status.textContent = `${message} (${percentage}%)`;
                status.style.background = '#ffc107';
            } else {
                status.textContent = message;
                status.style.background = '#17a2b8';
            }
        }

        
        function wrapLongDNA(text, chunk=64){
            
            return text.replace(/([ACGTNacgtn]{60,})/g, (m) => {
                return `<span class="seq-wrap">${m.replace(new RegExp(`(.{${chunk}})`, 'g'), '$1<wbr>')}</span>`;
            });
        }

        // Turn a long DNA string into stacked 64-char lines with a hover tooltip
        function asStackedDNA(s, chunk=64){
            if (!s) return s;
            const isDNA = /^[ACGTNacgtn]+$/.test(s);
            if (!isDNA || s.length <= chunk) return s;  
            const chunks = s.match(new RegExp(`.{1,${chunk}}`, 'g')) || [s];
            
            return `<span class="seq-block" title="${s}">${chunks.join('<br>')}</span>`;
        }

        
        function replaceLongDNAInHTML(html, chunk=64){
            return html.replace(/([ACGTNacgtn]{60,})/g, (m) => asStackedDNA(m, chunk));
        }


        function addMessage(sender, content) {
            const chatContainer = document.getElementById('chatContainer');
            const messageDiv = document.createElement('div');

            
            let isUser = false;
            let messageContent = '';
            let avatarText = 'ü§ñ';
            
            if (sender === '' || sender === 'ü§ñ') {
                
                isUser = false;
                messageContent = content || sender;
                avatarText = 'ü§ñ';
            } else if (typeof sender === 'string' && content) {
                
                isUser = false;
                messageContent = content;
                avatarText = sender;
            } else {
                
                isUser = true;
                messageContent = sender;
                avatarText = '';
            }
            
            messageDiv.className = `message ${isUser ? 'user' : 'bot'}`;
            
            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            avatar.textContent = avatarText;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            if (isUser) {
                // handles very long tokens; also wrap DNA with soft breaks
                const longTokenCheck   = /[^\s]{60,}/;
                const longTokenReplace = /[^\s]{60,}/g;

                const escapeHTML = (str) => str
                  .replace(/&/g, "&amp;")
                  .replace(/</g, "&lt;")
                  .replace(/>/g, "&gt;")
                  .replace(/"/g, "&quot;")
                  .replace(/'/g, "&#039;");

                const hasLongToken = longTokenCheck.test(messageContent);
                const isVeryLong   = messageContent.length > 300 || messageContent.split('\n').length > 10;

                if (hasLongToken) {
                   
                    let html = '';
                    let last = 0;
                    messageContent.replace(longTokenReplace, (match, offset) => {
                        const before = messageContent.slice(last, offset);
                        html += escapeHTML(before);
                        const wrapped = match.replace(/(.{64})/g, '$1<wbr>');
                        html += `<span class="seq-wrap">${wrapped}</span>`;
                        last = offset + match.length;
                        return match;
                    });
                    html += escapeHTML(messageContent.slice(last));
                    contentDiv.innerHTML = html;
                    contentDiv.classList.add('long-message');
                } else if (isVeryLong) {
                    contentDiv.textContent = messageContent;
                    contentDiv.classList.add('long-message');
                } else {
                    contentDiv.textContent = messageContent;
                }
            } else {
                
                let formattedContent = messageContent
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\n/g, '<br>');

               
                formattedContent = formattedContent.replace(/`([ACGTNacgtn\s]+)`/g, (m, p1) => {
                    const wrapped = p1.replace(/(.{64})/g, '$1<wbr>');
                    return `<code class="seq-wrap">${wrapped}</code>`;
                });
                formattedContent = wrapLongDNA(formattedContent, 64);

                contentDiv.innerHTML = formattedContent;
            }
            
            if (isUser) {
                messageDiv.appendChild(contentDiv);
                messageDiv.appendChild(avatar);
            } else {
                messageDiv.appendChild(avatar);
                messageDiv.appendChild(contentDiv);
            }
            
            chatContainer.appendChild(messageDiv);
            
            setTimeout(() => {
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }, 10);
        }

        function showTyping() {
            document.getElementById('typingIndicator').style.display = 'block';
            document.getElementById('chatContainer').scrollTop = document.getElementById('chatContainer').scrollHeight;
        }

        function hideTyping() {
            document.getElementById('typingIndicator').style.display = 'none';
        }

        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            if (!message) return;

            
            const compareCmd = /^\s*compare(?:\s+(?:the|two))?(?:\s+selected)?(?:\s+csvs?)?\s*$/i;
            if (compareCmd.test(message)) {
                
                addMessage(message);

                
                input.value = '';
                input.style.height = '50px';

                
                updateStatus('Comparing‚Ä¶', '#ffc107');
                

                try {
                    
                    await compareSelectedCSVs();
                } finally {
                    updateStatus('Ready');
                    
                }
                return; 
            }

            
            addMessage(message);
            input.value = '';
            input.style.height = '50px'; 
            
            showTyping();
            updateStatus('Processing...', '#ffc107');
            
            try {
                const response = await fetch('/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: message })
                });
                const data = await response.json();
                
                hideTyping();
                addMessage('ü§ñ', data.response);
                
                if (data.show_network) await showNetwork();
                if (data.show_depth)   await showDepth();
                updateStatus('Ready');
            } catch (error) {
                hideTyping();
                addMessage('ü§ñ', 'Sorry, I encountered an error. Please try again.');
                updateStatus('Error', '#dc3545');
                console.error('Error:', error);
            }
        }

        function sendExampleQuery(query) {
            document.getElementById('messageInput').value = query;
            sendMessage();
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }

        async function uploadData() {
            const fileInput = document.getElementById('dataFile');
            const files = fileInput.files;
            if (files.length === 0) { alert('Please select at least one CSV file'); return; }
            
            isAnalyzing = true;
            updateStatus('Analyzing data...', '#ffc107');
            updateProgress('Preprocessing data...', 10);
            
            const csvFiles = [];
            const depthFiles = [];
            const pdfFiles = [];
            
                
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const name = (file.name || '').toLowerCase();
                const ext = name.split('.').pop();
                if (name.includes('depth')) depthFiles.push(file);
                else if (ext === 'pdf') pdfFiles.push(file);
                else csvFiles.push(file);
            }
            
            
            for (let i = 0; i < depthFiles.length; i++) {
                const file = depthFiles[i];
                addMessage('ü§ñ', `üìä Processing depth file: ${file.name}`);
                try {
                    const fd = new FormData();
                    fd.append('file', file);
                    const res = await fetch('/upload_depth', { method: 'POST', body: fd });
                    const out = await res.json();
                    if (!out.success) {
                        addMessage('ü§ñ', `‚ùå Depth upload failed for ${file.name}: ${out.error || 'unknown error'}`);
                        continue;
                    }
                    addMessage('ü§ñ', `‚úÖ Depth file ${file.name} uploaded successfully! Ask for a depth plot to visualize sequencing depth.`);
                } catch (error) {
                    addMessage('ü§ñ', `‚ùå Error processing depth file ${file.name}: ${error.message}`);
                }
            }
            
            
            if (pdfFiles.length > 0) {
                if (pdfFiles.length === 1) {
                    const file = pdfFiles[0];
                    addMessage('ü§ñ', `üìÑ Processing PDF: ${file.name}`);
                    try {
                        const fd = new FormData();
                        fd.append('file', file);
                        const res = await fetch('/upload_file', { method: 'POST', body: fd });
                        const out = await res.json();
                        if (out.success) addMessage('ü§ñ', out.message);
                        else addMessage('ü§ñ', `‚ùå PDF processing failed for ${file.name}: ${out.error}`);
                    } catch (error) {
                        addMessage('ü§ñ', `‚ùå Error processing PDF ${file.name}: ${error.message}`);
                    }
                } else {
                    addMessage('ü§ñ', `üìÑ Processing ${pdfFiles.length} PDF files simultaneously...`);
                    try {
                        const fd = new FormData();
                        pdfFiles.forEach(file => fd.append('files', file));
                        const res = await fetch('/upload_multiple_pdfs', { method: 'POST', body: fd });
                        const out = await res.json();
                        if (out.success) addMessage('ü§ñ', out.message);
                        else addMessage('ü§ñ', `‚ùå Multi-PDF processing failed: ${out.error}`);
                    } catch (error) {
                        addMessage('ü§ñ', `‚ùå Error in multi-PDF processing: ${error.message}`);
                    }
                }
            }
            
            
            
if (csvFiles.length > 0) {
    if (csvFiles.length === 1) {
        const file = csvFiles[0];
        addMessage('ü§ñ', `üß¨ Analyzing microbiome data: ${file.name}`);
        try {
            const text = await file.text();
            const lines = text.split('\n');
            const headers = lines[0].split(',').map(h => h.trim());
            const otuData = {};
            headers.forEach(header => { otuData[header] = []; });
            for (let i = 1; i < lines.length; i++) {
                if (lines[i].trim()) {
                    const values = lines[i].split(',');
                    headers.forEach((header, index) => {
                        const value = values[index] ? values[index].trim() : '';
                        const numValue = parseFloat(value);
                        otuData[header].push(isNaN(numValue) ? value : numValue);
                    });
                }
            }
            updateProgress('Running R analysis...', 30);
            const response = await fetch('/analyze', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ otu_data: otuData, filename: file.name })
            });
            updateProgress('Processing results...', 80);
            const result = await response.json();
            if (result && result.error) addMessage('ü§ñ', `‚ùå Analysis failed for ${file.name}: ${result.error}`);
            else addMessage('ü§ñ', `üéâ Analysis complete! Found ${result.num_interactions || 0} interactions in ${file.name}. You can now ask questions or request visualizations.`);
                await updateFilesList();
        } catch (error) {
            addMessage('ü§ñ', `‚ùå Error processing ${file.name}: ${error.message}`);
        }
    } else if (csvFiles.length === 2) {
        addMessage('ü§ñ', `üß¨ Pairwise analysis for: ${csvFiles[0].name} & ${csvFiles[1].name}`);
        try {
            const filePromises = csvFiles.map(async (file) => {
                const text = await file.text();
                const lines = text.split('\n');
                const headers = lines[0].split(',').map(h => h.trim());
                const otuData = {};
                headers.forEach(header => { otuData[header] = []; });
                for (let i = 1; i < lines.length; i++) {
                    if (lines[i].trim()) {
                        const values = lines[i].split(',');
                        headers.forEach((header, index) => {
                            const value = values[index] ? values[index].trim() : '';
                            const numValue = parseFloat(value);
                            otuData[header].push(isNaN(numValue) ? value : numValue);
                        });
                    }
                }
                return { filename: file.name, otu_data: otuData };
            });
            const twoFiles = await Promise.all(filePromises);
            const resp = await fetch('/analyze_pairwise', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ files: twoFiles })
            });
            const out = await resp.json();
            if (!out.success) {
                addMessage('ü§ñ', `‚ö†Ô∏è Pairwise ingest/compare did not run: ${out.error || out.message || 'unknown issue'}`);
            } else {
                let msg = `‚úÖ ${out.message}`;
                if (out.pairwise_type && out.pairwise_type !== 'ingested') {
                    msg += ` (type: ${out.pairwise_type})`;
                }
                addMessage('ü§ñ', msg);
                await updateFilesList();
                if (out.pairwise_type === 'interactions' && out.comparison) {
                    const c = out.comparison;
                    addMessage('ü§ñ', `Overlap edges: ${c.overlap_edges_count} | Added: ${c.added_edges_count} | Removed: ${c.removed_edges_count}`);
                }
            }
        } catch (error) {
            addMessage('ü§ñ', `‚ùå Error in pairwise analysis: ${error.message}`);
        }
    } else {
        addMessage('ü§ñ', `üß¨ Ingesting ${csvFiles.length} microbiome CSVs.`);
        try {
            const filePromises = csvFiles.map(async (file) => {
                const text = await file.text();
                const lines = text.split('\n');
                const headers = lines[0].split(',').map(h => h.trim());
                const otuData = {};
                headers.forEach(header => { otuData[header] = []; });
                for (let i = 1; i < lines.length; i++) {
                    if (lines[i].trim()) {
                        const values = lines[i].split(',');
                        headers.forEach((header, index) => {
                            const value = values[index] ? values[index].trim() : '';
                            const numValue = parseFloat(value);
                            otuData[header].push(isNaN(numValue) ? value : numValue);
                        });
                    }
                }
                return { filename: file.name, otu_data: otuData };
            });
            const allFilesData = await Promise.all(filePromises);
            updateProgress('Running R analysis...', 30);
            const response = await fetch('/analyze_multiple', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ files: allFilesData })
            });
            const result = await response.json();
            updateProgress('Processing results...', 80);
            if (result && result.error) addMessage('ü§ñ', `‚ùå Multi-file ingest failed: ${result.error}`);
            else {
                addMessage('ü§ñ', result.message);
                if (result.success) addMessage('ü§ñ', `üìä All datasets are now available. Ask for "summary", "network visualization", or specific questions about the interactions or taxonomy.`);
            }
        } catch (error) {
            addMessage('ü§ñ', `‚ùå Error in multi-file ingest: ${error.message}`);
        }
    }
}

            updateStatus('Ready');
            updateProgress('Complete!', 100);
            setTimeout(() => updateStatus('Ready'), 2000);
        }

        async function showNetwork() {
            try {
                const response = await fetch('/network');
                const data = await response.json();
                if (data.error) { addMessage('ü§ñ', `Cannot generate network: ${data.error}`); return; }
                
                const networkContainer = document.createElement('div');
                networkContainer.className = 'network-container';
                networkContainer.innerHTML = '<h3>Interaction Network</h3>';
                
                const plotDiv = document.createElement('div');
                plotDiv.style.height = '400px';
                networkContainer.appendChild(plotDiv);
                
                const stats = data.network_stats || {};
                const statsDiv = document.createElement('div');
                statsDiv.innerHTML = `
                    <p><strong>Network Statistics:</strong></p>
                    <p>Nodes: ${data.network_stats.nodes} | Edges: ${data.network_stats.edges}</p>
                    <p>Density: ${data.network_stats.density.toFixed(3)} | Avg Clustering: ${data.network_stats.avg_clustering.toFixed(3)}</p>
                `;
                networkContainer.appendChild(statsDiv);
                
                document.getElementById('chatContainer').appendChild(networkContainer);
                
                const plotData = JSON.parse(data.plot_json);
                Plotly.newPlot(plotDiv, plotData.data, plotData.layout, {responsive:true});
                
                plotDiv.on('plotly_click', (ev) => {
                    const pt = ev?.points?.[0];
                    const cd = pt?.customdata;
                    if (Array.isArray(cd) && cd.length >= 2) {
                        const s1 = cd[0], s2 = cd[1], label = cd[2] || 'Unknown';
                        
                        openExplainPanel();
                        const a = document.getElementById('exSpecies1'); if (a) a.value = s1;
                        const b = document.getElementById('exSpecies2'); if (b) b.value = s2;
                        const c = document.getElementById('exLabel');    if (c) c.value = label || '';
                        explainEdge(s1, s2, label);
                    }
                });

                document.getElementById('chatContainer').scrollTop = document.getElementById('chatContainer').scrollHeight;
            } catch (error) {
                addMessage('ü§ñ','Error generating network visualization.');
                console.error('Network error:', error);
            }
        }

        async function showDepth() {
            try {
                const res = await fetch('/depth');
                const data = await res.json();
                if (!data.success) { addMessage('ü§ñ', `Depth viewer error: ${data.error || 'not available'}`); return; }

                const card = document.createElement('div');
                card.className = 'network-container';
                card.innerHTML = '<h3>Depth Plot Viewer</h3>';

                const distDiv = document.createElement('div'); distDiv.style.height = '360px';
                const cdfDiv  = document.createElement('div'); cdfDiv.style.height  = '360px';
                const sampDiv = document.createElement('div'); sampDiv.style.height = '360px';
                const groupDiv= document.createElement('div'); groupDiv.style.height= '360px';

                const s = data.qc_summary;
                const qc = document.createElement('div');
                qc.innerHTML = `
                  <p><strong>QC Summary</strong></p>
                  <p>Samples: ${s.n_samples} | Median: ${Math.round(s.median)} | Mean: ${Math.round(s.mean)} | Q1/Q3: ${Math.round(s.q1)}/${Math.round(s.q3)} | Low-depth threshold: ${Math.round(s.low_depth_threshold)} | Flagged: ${s.n_flagged_low_depth}</p>
                `;
                card.appendChild(qc);

                const plotHdr1 = document.createElement('p'); plotHdr1.innerHTML = '<strong>Distribution</strong>';
                const plotHdr2 = document.createElement('p'); plotHdr2.innerHTML = '<strong>Empirical CDF</strong>';
                const plotHdr3 = document.createElement('p'); plotHdr3.innerHTML = '<strong>Per Sample (sorted)</strong>';
                const plotHdr4 = document.createElement('p'); plotHdr4.innerHTML = '<strong>By Group (if available)</strong>';

                card.appendChild(plotHdr1); card.appendChild(distDiv);
                card.appendChild(plotHdr2); card.appendChild(cdfDiv);
                card.appendChild(plotHdr3); card.appendChild(sampDiv);
                card.appendChild(plotHdr4); card.appendChild(groupDiv);

                document.getElementById('chatContainer').appendChild(card);

                const distFig = JSON.parse(data.fig_distribution);
                const sampFig = JSON.parse(data.fig_per_sample);
                const cdfFig  = JSON.parse(data.fig_cdf);
                Plotly.newPlot(distDiv, distFig.data, distFig.layout, {responsive:true});
                Plotly.newPlot(sampDiv, sampFig.data, sampFig.layout, {responsive:true});
                Plotly.newPlot(cdfDiv,  cdfFig.data,  cdfFig.layout,  {responsive:true});

                if (data.fig_by_group) {
                    const groupFig = JSON.parse(data.fig_by_group);
                    Plotly.newPlot(groupDiv, groupFig.data, groupFig.layout, {responsive:true});
                } else {
                    groupDiv.innerHTML = '<p class="muted">No grouping column detected in <code>depth.csv</code>.</p>';
                }

                document.getElementById('chatContainer').scrollTop = document.getElementById('chatContainer').scrollHeight;
            } catch (e) {
                addMessage('ü§ñ','Error loading depth plots.');
                console.error(e);
            }
        }

        function showExplanationModal(explanation) {
            const explanationContainer = document.createElement('div');
            explanationContainer.className = 'network-container';
            explanationContainer.innerHTML = `
                <h3> Why Logic Explanation</h3>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <h4>${explanation.interaction_pair}</h4>
                    <p><strong>Type:</strong> ${explanation.interaction_type}</p>
                    <p><strong>Compression Value:</strong> ${explanation.compression_value.toFixed(3)}</p>
                    <p><strong>Confidence Level:</strong> ${explanation.confidence_level}</p>
                </div>
            `;
            if (explanation.logical_reasoning) {
                const logicalDiv = document.createElement('div');
                logicalDiv.innerHTML = `
                    <h4> Logical Reasoning</h4>
                    <div style="background: #e3f2fd; padding: 12px; border-radius: 6px; margin-bottom: 10px;">
                        <p><strong>Primary Rule:</strong> ${explanation.logical_reasoning.primary_rule}</p>
                        <p><strong>Compression Rule:</strong> ${explanation.logical_reasoning.compression_rule}</p>
                    </div>
                `;
                if (explanation.logical_reasoning.abductive_reasoning) {
                    logicalDiv.innerHTML += `
                        <p><strong>Abductive Reasoning Steps:</strong></p>
                        <ul>${explanation.logical_reasoning.abductive_reasoning.map(step => `<li>${step}</li>`).join('')}</ul>
                    `;
                }
                if (explanation.logical_reasoning.logical_chain) {
                    logicalDiv.innerHTML += `
                        <p><strong>Logical Chain:</strong></p>
                        <ol>${explanation.logical_reasoning.logical_chain.map(step => `<li>${step}</li>`).join('')}</ol>
                    `;
                }
                explanationContainer.appendChild(logicalDiv);
            }
            if (explanation.evidence_analysis) {
                const evidenceDiv = document.createElement('div');
                evidenceDiv.innerHTML = `
                    <h4> Evidence Analysis</h4>
                    <div style="background: #fff3cd; padding: 12px; border-radius: 6px; margin-bottom: 10px;">
                        <p><strong>Data Source:</strong> ${explanation.evidence_analysis.data_source}</p>
                        <p><strong>Analysis Method:</strong> ${explanation.evidence_analysis.analysis_method}</p>
                        <p><strong>Evidence Types:</strong> ${explanation.evidence_analysis.evidence_types.join(', ')}</p>
                    </div>
                    <p><strong>Supporting Factors:</strong></p>
                    <ul>${explanation.evidence_analysis.supporting_factors.map(f => `<li>${f}</li>`).join('')}</ul>
                `;
                explanationContainer.appendChild(evidenceDiv);
            }
            if (explanation.biological_interpretation) {
                const bioDiv = document.createElement('div');
                bioDiv.innerHTML = `
                    <h4> Biological Interpretation</h4>
                    <div style="background: #d4edda; padding: 12px; border-radius: 6px;">
                        <p><strong>Mechanism:</strong> ${explanation.biological_interpretation.mechanism}</p>
                        <p><strong>Examples:</strong> ${explanation.biological_interpretation.examples}</p>
                        <p><strong>Ecological Role:</strong> ${explanation.biological_interpretation.ecological_role}</p>
                    </div>
                `;
                explanationContainer.appendChild(bioDiv);
            }
            if (explanation.statistical_support) {
                const statsDiv = document.createElement('div');
                statsDiv.innerHTML = `
                    <h4> Statistical Support</h4>
                    <div style="background: #f8d7da; padding: 12px; border-radius: 6px;">
                        <p><strong>Interpretation:</strong> ${explanation.statistical_support.interpretation}</p>
                        <p><strong>Validation Method:</strong> ${explanation.statistical_support.validation_method}</p>
                        <p><strong>Robustness:</strong> ${explanation.statistical_support.robustness}</p>
                        <p><strong>Significance Level:</strong> ${explanation.statistical_support.significance_level}</p>
                    </div>
                `;
                explanationContainer.appendChild(statsDiv);
            }
            if (explanation.alternative_hypotheses && explanation.alternative_hypotheses.length > 0) {
                const altDiv = document.createElement('div');
                altDiv.innerHTML = `
                    <h4> Alternative Hypotheses Considered</h4>
                    <div style="background: #e2e3e5; padding: 12px; border-radius: 6px;">
                `;
                explanation.alternative_hypotheses.forEach(alt => {
                    altDiv.innerHTML += `<p><strong>${alt.hypothesis}:</strong> ${alt.reason_rejected}</p>`;
                });
                altDiv.innerHTML += `</div>`;
                explanationContainer.appendChild(altDiv);
            }

            document.getElementById('chatContainer').appendChild(explanationContainer);
            document.getElementById('chatContainer').scrollTop = document.getElementById('chatContainer').scrollHeight;
        }

        
        function openExplainPanel(){
            const header  = document.getElementById('edgeExplainToggle');
            const content = document.getElementById('edgeExplainContent');
            if (header && content && content.hasAttribute('hidden')) {
                content.removeAttribute('hidden');
                header.setAttribute('aria-expanded', 'true');
            }
        }

        async function uploadFiles(fileType) {
            let fileInput, endpoint;
            if (fileType === 'pdf') { fileInput = document.getElementById('pdf-upload'); endpoint = '/upload_file'; }
            else { return; }
            
            const files = fileInput.files;
            if (files.length === 0) { alert(`Please select at least one ${fileType.toUpperCase()} file`); return; }
            
            for (let file of files) {
                const formData = new FormData();
                formData.append('file', file);
                try {
                    addMessage('', ` Uploading ${file.name}...`);
                    const response = await fetch(endpoint, { method: 'POST', body: formData });
                    const result = await response.json();
                    if (result.success) { addMessage('', ` ${file.name} uploaded successfully!`); updateFilesList(); }
                    else { addMessage('', ` Upload failed for ${file.name}: ${result.error}`); }
                } catch (error) {
                    addMessage('', ` Error uploading ${file.name}: ${error.message}`);
                }
            }
            fileInput.value = '';
        }

        
async function updateFilesList() {
    try {
        const response = await fetch('/get_uploaded_files');
        const result = await response.json();
        const filesDisplay = document.getElementById('files-display');
        if (result.success && result.files) {
            let html = '';
            const csvs = result.files.csv_files || {};
            if (Object.keys(csvs).length > 0) {
                html += '<h5>CSV Files:</h5>';
                html += '<ul style="list-style:none;padding-left:0;margin:0">';
                for (const [filename, info] of Object.entries(csvs)) {
                    const stamp = info && info.timestamp ? ` <span style="color:#6c757d">(${info.timestamp})</span>` : '';
                    html += `<li style="margin:6px 0">
                        <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
                            <input type="checkbox" class="csv-checkbox" value="${filename}">
                            <span>${filename}${stamp}</span>
                        </label>
                    </li>`;
                }
                html += '</ul>';
            } else {
                html = '<p>No CSVs uploaded yet.</p>';
            }
            filesDisplay.innerHTML = html;
        }
    } catch (err) {
        console.error('updateFilesList failed:', err);
    }
}
async function deleteSelectedCSVs() {
    const checked = Array.from(document.querySelectorAll('.csv-checkbox:checked')).map(x => x.value);
    if (checked.length === 0) {
        addMessage('ü§ñ', '‚ö†Ô∏è No CSVs selected. Please check one or more CSVs in the left panel, then say **delete selected csvs**.');
        return;
    }
    
    try {
        const res = await fetch('/delete_csvs', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ filenames: checked })
        });
        const result = await res.json();
        
        if (result.success) {
            addMessage('ü§ñ', `‚úÖ ${result.message}: ${result.deleted_files.join(', ')}`);
            if (result.errors.length > 0) {
                addMessage('ü§ñ', `‚ö†Ô∏è Errors: ${result.errors.join(', ')}`);
            }
            await updateFilesList(); 
        } else {
            addMessage('ü§ñ', `‚ùå Delete failed: ${result.error}`);
        }
    } catch (e) {
        addMessage('ü§ñ', `‚ùå Delete error: ${e.message}`);
    }
}

        async function refreshChatHistory() {
            try {
                const response = await fetch('/history');
                const data = await response.json();
                if (data.success) {
                    const chatContainer = document.getElementById('chatContainer');
                    chatContainer.innerHTML = '';
                    data.chat_history.forEach(message => { addMessage(message.sender, message.content); });
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                }
            } catch (error) {
                console.error('Error refreshing chat history:', error);
            }
        }

        function autoResize(textArea) {
            textArea.style.height = '50px';
            const newHeight = Math.min(textArea.scrollHeight, 150);
            textArea.style.height = newHeight + 'px';
            const cursorPosition = textArea.selectionStart;
            const textBeforeCursor = textArea.value.substring(0, cursorPosition);
            const lines = textBeforeCursor.split('\n');
            const currentLine = lines.length;
            const lineHeight = parseInt(window.getComputedStyle(textArea).lineHeight);
            if (currentLine * lineHeight > textArea.scrollTop + textArea.clientHeight) {
                textArea.scrollTop = (currentLine * lineHeight) - textArea.clientHeight + lineHeight;
            }
        }


    async function explainEdge(species1, species2, label) {
        
        if (!species1 || !species2) {
            species1 = (document.getElementById('exSpecies1')?.value || '').trim();
            species2 = (document.getElementById('exSpecies2')?.value || '').trim();
            label    = (document.getElementById('exLabel')?.value || '').trim();
        }

        const chat = document.getElementById('chatContainer');
        const card = document.createElement('div');
        card.className = 'network-container';
        card.innerHTML = `<h3>Proof trace</h3><p class="muted">Explaining <code>${species1}</code> vs <code>${species2}</code>‚Ä¶</p>`;
        chat.appendChild(card);
        chat.scrollTop = chat.scrollHeight;

        if (!species1 || !species2) {
            card.innerHTML = `<h3>Proof trace</h3><p style="color:#dc3545">‚ùå Please provide both species names.</p>`;
            return;
        }

        try {
            const res = await fetch('/explain_detailed', {
                method: 'POST',
                headers: {'Content-Type':'application/json'},
                body: JSON.stringify({ species1, species2, label: label || 'Unknown' })
            });
            const out = await res.json();
            if (!out.success) {
                card.innerHTML = `<h3>Proof trace</h3><p style="color:#dc3545">‚ùå ${out.error || 'Could not explain this interaction.'}</p>`;
                return;
            }
            renderProofCard(card, species1, species2, label, out);
        } catch (e) {
            card.innerHTML = `<h3>Proof trace</h3><p style="color:#dc3545">‚ùå ${e.message}</p>`;
        }
    }

    function renderProofCard(container, species1, species2, label, data) {
        
        const steps = (data.steps || []).map(s => `<li>${escapeHtml(s)}</li>`).join('');

        const ev = data.evidence || {};
        const med = ev.median || {};
        const counts = ev.counts || {};
        const fracs = ev.fractions || {};
        const corr = ev.correlation || {};
        const rules = (ev.rule_texts || []).map(r => `<li>${escapeHtml(r)}</li>`).join('');

        container.innerHTML = `
    <h3>Proof trace: <code>${escapeHtml(species1)}</code> ‚Üî <code>${escapeHtml(species2)}</code>${label ? ` <small class="muted">(${escapeHtml(label)})</small>` : ''}</h3>
    <ol style="margin:8px 0 12px 20px">${steps}</ol>

    <details>
      <summary>Evidence details</summary>
      <div style="margin-top:8px">
        <p class="muted">Samples used: <strong>${ev.n_samples ?? '‚Äî'}</strong></p>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
          <div>
            <p><strong>Medians</strong></p>
            <p><code>${escapeHtml(species1)}</code>: ${fmtNum(med[species1])} &nbsp;¬∑&nbsp; <code>${escapeHtml(species2)}</code>: ${fmtNum(med[species2])}</p>
          </div>
          <div>
            <p><strong>Correlation</strong></p>
            <p>Spearman: ${fmtNum(corr.spearman)} &nbsp;¬∑&nbsp; Pearson: ${fmtNum(corr.pearson)}</p>
          </div>
        </div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px">
          <div>
            <p><strong>Counts</strong></p>
            <p>both-high=${counts.both_high ?? '‚Äî'}, both-low=${counts.both_low ?? '‚Äî'}, hi-low=${counts.hi_low ?? '‚Äî'}, low-hi=${counts.low_hi ?? '‚Äî'}</p>
          </div>
          <div>
            <p><strong>Fractions</strong></p>
            <p>concordant=${fmtNum(fracs.concordant)}, discordant=${fmtNum(fracs.discordant)}</p>
          </div>
        </div>
        <div style="margin-top:8px">
          <p><strong>Derived rules</strong></p>
          <ul style="margin-left:18px">${rules || '<li class="muted">No strong rule fired; showing descriptive stats.</li>'}</ul>
        </div>
      </div>
    </details>
    `;
    
    container.innerHTML = replaceLongDNAInHTML(container.innerHTML);
    }
    
    function fmtNum(v) { return (v === undefined || v === null || Number.isNaN(v)) ? '‚Äî' : (typeof v === 'number' ? (''+v) : escapeHtml(v)); }
    function escapeHtml(s) {
        return String(s ?? '').replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
    }

    
    async function runNullTest() {
        const chat = document.getElementById('chatContainer');
        const card = document.createElement('div');
        card.className = 'network-container';
        card.innerHTML = `<h3>Null/random comparison</h3><p class="muted">Running‚Ä¶</p>`;
        chat.appendChild(card);
        chat.scrollTop = chat.scrollHeight;

        try {
            const res = await fetch('/network_null_test?n=200');
            const out = await res.json();
            if (!out.success) {
                card.innerHTML = `<h3>Null/random comparison</h3><p style="color:#dc3545">‚ùå ${out.error || 'Failed.'}</p>`;
                return;
            }
            card.innerHTML = `
      <h3>Null/random comparison</h3>
      <p>Observed mean |Spearman| on inferred edges: <strong>${out.observed_mean_abs_spearman}</strong></p>
      <p>Null mean: ${out.null_mean} &nbsp;¬∑&nbsp; Null std: ${out.null_std}</p>
      <p>Z-score: <strong>${out.z_score}</strong> &nbsp;¬∑&nbsp; Permutation p (upper tail): <strong>${out.permutation_p_upper}</strong></p>
      <p class="muted">Pairs tested: ${out.num_inferred_pairs_tested} &nbsp;¬∑&nbsp; Null draws: ${out.num_null_draws}</p>
    `;
        } catch (e) {
            card.innerHTML = `<h3>Null/random comparison</h3><p style="color:#dc3545">‚ùå ${e.message}</p>`;
        }
    }

document.addEventListener("copy", (e) => {
  const selection = window.getSelection();
  if (!selection.rangeCount) return;

  const node = selection.anchorNode;
  if (!node) return;

  
  const cell = node.nodeType === 1 ? node : node.parentElement;
  if (cell && cell.dataset && cell.dataset.fullvalue) {
    e.clipboardData.setData("text/plain", cell.dataset.fullvalue);
    e.preventDefault();  
  }
});

    </script>
    <script>
       
        (function () {
          const sleep = (ms) => new Promise(r => setTimeout(r, ms));
          const originalSendMessage = window.sendMessage;
        
          async function networkIsReady() {
            try {
              const r = await fetch('/network');
              const j = await r.json();
              return !!j && !!j.plot_json;
            } catch (e) { return false; }
          }
        
          async function ensureAnalyzedAndReady() {
            
            if (await networkIsReady()) return true;
        
            
            const input = document.getElementById('dataFile');
            if (input && input.files && input.files.length) {
              addMessage('ü§ñ','No analysis in memory ‚Äî running ‚ÄúUpload & Analyze‚Äù‚Ä¶');
              await uploadData(); 
        
              
              for (let i = 0; i < 20; i++) {
                if (await networkIsReady()) return true;
                await sleep(1000);
              }
              addMessage('ü§ñ','Analysis finished, but network is not ready yet. Try ‚Äúshow me network‚Äù again or check logs.');
              return false;
            }
        
            
            addMessage('ü§ñ','No analysis data available. Choose your CSV(s) in the left panel and click ‚ÄúUpload & Analyze‚Äù, then try again.');
                return false;
              }
        
        
          
          window.sendMessage = async function patchedSendMessage() {
            const input = document.getElementById('messageInput');
            const msg = (input.value || '').trim();
            const low = msg.toLowerCase();
        
            // 2) show network (analyze if needed, then call the existing showNetwork again)
            
            const looksLikeFilter = /\bwith\b|[<>]=?|abundance|compression|top\s+\d+|filter/.test(low);
            if (!looksLikeFilter && /(show|plot|display|generate).*\bnetworks?\b/.test(low)) {
              addMessage(msg); input.value = ''; input.style.height = '50px';
              if (await ensureAnalyzedAndReady()) { await showNetwork(); }
              return;
            }
        
            // 3) depth qc shortcut
            if (/(depth|qc|rarefaction)/.test(low)) {
              addMessage(msg); input.value = ''; input.style.height = '50px';
              await showDepth();
              return;
            }
        
            
            return originalSendMessage();
          };
        })();
        </script>
        <script>
            
            (function () {
              
              function getAllFileCheckboxes() {
                return Array.from(document.querySelectorAll('#files-display .csv-checkbox'));
              }
              function deselectAllFiles() {
                getAllFileCheckboxes().forEach(b => { b.checked = false; });
              }
              function selectFileByName(name) {
                let hit = false;
                getAllFileCheckboxes().forEach(b => {
                  const text = (b.closest('label')?.innerText || '').trim();
                  if (text.toLowerCase().includes(name.toLowerCase())) { b.checked = true; hit = true; }
                });
                return hit;
              }
              async function previewNow() {
                try { await previewSelectedCSVs(); } catch (e) { addMessage('ü§ñ', 'Preview failed: ' + e.message); }
              }
            
              
              (function waitAndPatch(){
                if (typeof window.sendMessage !== 'function') { setTimeout(waitAndPatch, 50); return; }
                const originalSendMessage = window.sendMessage;
            
                window.sendMessage = async function patchedSendMessage () {
                  const input = document.getElementById('messageInput');
                  const msg = (input.value || '').trim();
                  const low = msg.toLowerCase();
            
                  // 1) Deselects all
                  if (/^(deselect all|clear selection|unselect all|deselect csvs|deselect all csvs|deselect csv)$/i.test(msg)) {
                    addMessage(msg);
                    deselectAllFiles();
                    input.value = ''; input.style.height = '50px';
                    addMessage('ü§ñ','Deselected all CSVs.');
                    return;
                  }
            
                  // 2) preview <file>.csv  ‚Üí select, then call previewSelectedCSVs()
                  const m = msg.match(/^\s*preview\s+([\w\-.]+\.csv)\s*$/i);
                  if (m) {
                    addMessage(msg);
                    input.value = ''; input.style.height = '50px';
                    const ok = selectFileByName(m[1]);
                    if (!ok) { addMessage('ü§ñ', `Couldn‚Äôt find ${m[1]} in the list.`); return; }
                    await previewNow();
                    return;
                  }
            
                  // 3) preview selected
                  if (/^\s*preview\s+(selected|selected\s+csvs?)\s*$/i.test(low)) {
                    addMessage(msg);
                    input.value = ''; input.style.height = '50px';
                    await previewNow();
                    return;
                  }

                  // 4) delete selected csvs
                  if (/(delete|remove).*(selected|checked)?\s*(csv|csvs?)/.test(low)) {
                    addMessage(msg); 
                    input.value = ''; 
                    input.style.height = '50px';
                    await deleteSelectedCSVs();
                    return;
                  }
            
                  
                  return originalSendMessage();
                };
              })();
            })();
            </script>
</body>
</html>
